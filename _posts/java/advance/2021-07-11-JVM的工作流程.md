---
layout: articles
title: JVM的工作流程
tags:  JVM基础
author: WarNing
key:    java-advance-head-19
aside:
  toc: true
sidebar:
nav: Java
category: [java, advance]
---


<!--more-->


## **一、JVM是什么？**

Java的流行很大一个因素都得益于它是一门款跨平台的语言，只需一次编译就可以在各个不同的平台运行。严格来说跨平台的特性并非Java语言的特性，其实提供这个特性的是JVM，只是我们经常说Java时默认已经把JVM算进来了。

这么说虽然没错但是确实不太准确，而且JVM从设计上看也并非只想运行Java语言，而是面向所有语言的运行平台，只要遵守JVM的约定(只要编译成.class文件)，那么任何语言都可以运行在JVM虚拟机上的，现在确实也有除了Java之外的很多语言都是运行在JVM上了，比如scala、kotlin、groovy等，所以综合来说JVM其实是一个独立的个体，它是一个可以运行任何语言的平台。



![img](https://pic4.zhimg.com/80/v2-d04887ad9c193054dd11c53c73680ce7_720w.jpg)

------

## **二、JDK、JRE、JVM的关系**

首先需要确定的是JDK里是包含JRE的，而JRE里又包含JVM，它们区别在于面向的服务对象不同所以进行了不同的包装。

JVM：JVM是面向操作系统的，它负责把程序运行编译成的.Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行的内存的管理。

JRE：JRE是是面向于程序的，JRE对JVM进行了一层包装，它除了提供JVM的功能之前，还提供了一套语言需要编译成Class后在JVM内运行所依赖环境（比如说 String.class、Object.class等这种运行时必须依赖的对象）。

JDK：JDK是面向更上层的开发人员，JDK在JRE的基础上又进行了一层包装，它除了提供运行功能之外，还对开发人员提供了一套常用的开发工具和类库，来方便开发人员写代码（比如说方便部署的编译工具，方便开发的工具类等）。

![img](https://pic2.zhimg.com/80/v2-474bb4a444f55c754e26be7a54a3e5cd_720w.jpg)

------

## **三、JVM的工作流程**

上面我们了解一些基本的概念后，下面开始正式进入到JVM的内容，我们首先从整体上对JVM的工作流程进行

分析和了解。从文章的第一张图我们知道，JVM只负责解释执行层面的工作，而具体的编译工作是没有纳入到JVM工作范围的，但是为了更清晰的理解JVM的功能我们又必须从编译开始了解。



**一个java文件从编码到执行需要经过下面几个阶段**

1、编译阶段：首先.java经过javac编译成.class文件

2、加载阶段：然后.class文件经过类的加载器加载到JVM内存。

3、解释阶段：class字节码经过字节码解释器解释成系统可识别的指令码。

4、执行阶段：系统再向硬件设备发送指令码执行操作。



![img](https://pic3.zhimg.com/80/v2-56609c83569bd4f6f268a829b098a196_720w.jpg)



### **1、编译阶段**

类的编译阶段主要目的是把源码文件编译成JVM可以解析的class文件，这个阶段会经过词法分析、语法语义分析、生成字节码，这个几个阶段后生成最后的class, 用16进制的方式打开class文件后内容大概如下图



![img](https://pic4.zhimg.com/80/v2-5f4db34aebda8e0ed97d8b966bb9ab5f_720w.jpg)







### **class文件包含下面几部分内容**

**Magic Number(魔数)：** 在.class文件头4个字节如图“CA FE BA BE”内容，魔数的作用就是定义一个识别标准，只有符合这个标准才能被JVM解读 。

**版本号:** 编译class文件的JDK版本号，此版本时向下兼容的。

**常量池:** 常量池中信息主要包括字面量（字符串（String a=“b”）、基本类型的常量（final 修饰的变量））和符号引用（类和接口全限定名，字段名称和描述符、方法名称和描述符，方法句柄和方法类型，动态调用点和动态常量）。

**访问标志:** 该类是否为接口、注释、枚举、模块，是否为final ,abstract等信息。

**类索引:** 类索引、父类索引、接口索引集合，用于确定类的继承和实现关系。

**字段表集合：**用于描述接口或者类中声明的变量信息，如修饰作用域（public,private,protected）,是实例变量还是类变量(static)，是否可变(final),是否可序列化(transient),并发可见性(volatile)，字段数据类型，字段名。

**方法表集合：**方法表集合和字段表的信息类似，只不过这里保存的是保存方法相关的信息，包括方法的名称，访问标志(如public 、static 、final、abstract、native、sychronized等)，名称索引，属性表集合（在方法内定义的属性、方面里面的代码指令）等信息。

**属性表集合:** 包括类、方法、实例的变量属性和代码的指令码。



### **2、加载阶段**

加载阶段主要是把编译阶段生成的.class文件加载到JVM内存中去，这个阶段会经过装载、连接、初始化三个过程。

### **2.1、装载**

装载阶段主要做的事情就是先把class的信息读到内存来。

（1）先通过类的全限定名读取到描述此类的二进制流。

（2）把字节流中描述静态结构的信息转化为方法区中的运行时数据结构。

（3）在Java堆中生成一个代表这个类的java.lang.Class对象，作为这个对象的访问入口。



```java
public class TestJVM {

    public static int a;
    public static TestJVM testJVM;

    static {
        a=88;
        testJVM=new TestJVM();
    }

}
```

上面的代码经过加载阶段后会在JVM内存保存着类的字节码，并且会生成一个TestJVM.Class对象，这个对象是作为TestJVM.class的统一访问入口，下图是按逻辑分区，并非数据实际保存物理位置。

![img](https://pic3.zhimg.com/80/v2-c3e0237733011371dcb06f952561d2e2_720w.jpg)



### 2.2、**连接**

连接阶段会对class的信息进行验证、为类变量分配内存空间并对其赋默认值。

（1）验证 :对class内容进行验证看字节信息是否符合JVM规范，包括元数据、字节码、符号引用的验证。

（2）准备: 为静态变量（final 和static定义的变量）分配内存空间，初始化静态变量值( int a=0, object=null的操作)。

（3）解析：把符号引用转换为直接引用，因为这里类的信息已经被加载到内存了，所以这里会把原来通过全限定名引用的对象替换成对象内存的实际地址。

![img](https://pic2.zhimg.com/80/v2-8961df925ef3aef0d6df2687d5043b7d_720w.jpg)

### 2.3、**初始化**

初始化阶段主要是执行初始化静态块内容，并且为静态变量进行真正的赋值操作，这里JVM会通过执行编译器自动生成的<clinit>() 方法（此方法是编译器通过搜集类的static{}静态快组成的代码）而完成具体工作。

![img](https://pic3.zhimg.com/80/v2-d6dcd8696b8d5b5507512e0db8df02d2_720w.jpg)



### **3、解释阶段**

解释阶段是在代码执行的时候来触发的，当我们尝试执行一个类的方法时，首先会通过这个类的对象作为入口，找到对应方法的字节码的信息，然后解析器会把字节码信息解释成系统能识别的指令码。

解释阶段会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器JIT，一般来说当我们运行某个代码的时候会默认使用字节码解释器进行指令解析，只有当某个方法称为热点方法后，即时编译器就会把热点方法的指令码保存起来，下次方法执行的时候就无需重复的进行解析，所以JIT是对解析过程中的一种优化手段。



### **4、执行阶段**

操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。
# 附录
## A 资源
## B 参考资料


